<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ranking de Tudo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Garante que a tela de resultados seja rolável se o conteúdo for grande */
        #main-container {
            width: 100%;
            max-width: 56rem; /* max-w-5xl */
            padding: 1rem;
        }
        #results-screen {
            max-height: 100vh;
            overflow-y: auto;
        }
        .card {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .card:hover:not(.no-hover) {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        #results-list li {
            background-color: #f9fafb;
            border-left-width: 4px;
        }
        #results-list li:nth-child(1) { border-color: #f59e0b; } /* Ambar */
        #results-list li:nth-child(2) { border-color: #a3a3a3; } /* Cinza */
        #results-list li:nth-child(3) { border-color: #a16207; } /* Bronze */

        /* Animações */
        @keyframes press-animation {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }
        @keyframes fade-out-animation {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .winner-animation {
            animation: press-animation 0.4s ease-in-out forwards;
        }
        .loser-animation {
            animation: fade-out-animation 0.4s ease-in-out forwards;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div id="main-container" class="text-center">
        
        <!-- Tela Inicial -->
        <div id="setup-screen">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Ranking de Tudo</h1>
            <p class="text-gray-600 mb-6">Digite ou cole uma lista de itens (um por linha) para começar a ranquear.</p>
            <textarea id="item-list" class="w-full h-48 p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Exemplo:&#10;Pizza&#10;Hambúrguer&#10;Sushi&#10;..."></textarea>
            
            <div id="list-stats" class="text-left text-sm text-gray-500 mt-3 mx-auto max-w-md">
                <p>Itens: <span id="item-count" class="font-semibold">0</span></p>
                <p>Escolhas (máx.): <span id="choices-count" class="font-semibold">0</span></p>
            </div>

            <button id="start-btn" class="mt-4 w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-lg">Começar a Ranquear</button>
        </div>

        <!-- Tela de Comparação -->
        <div id="battle-screen" class="hidden flex flex-col justify-between min-h-[60vh]">
            <h2 class="text-2xl font-semibold">Qual você prefere?</h2>
            
            <!-- Correção para botões de tamanho igual -->
            <div class="grid grid-cols-2 gap-4 my-4 flex-grow">
                <button id="item-a" class="card p-4 bg-white rounded-lg border border-gray-200 text-2xl font-semibold grid place-items-center min-h-[12rem]"></button>
                <button id="item-b" class="card p-4 bg-white rounded-lg border border-gray-200 text-2xl font-semibold grid place-items-center min-h-[12rem]"></button>
            </div>

             <div class="w-full">
                <p id="progress-text" class="text-gray-500 mb-2"></p>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300 ease-out"></div>
                </div>
                <p class="mt-2 text-sm text-gray-500">Clique para escolher ou use as setas ⬅️ e ➡️</p>
                <div class="flex gap-4 mt-4">
                    <button id="restart-battle-btn" class="flex-1 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors text-sm">Reiniciar</button>
                    <button id="finish-early-btn" class="flex-1 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors text-sm">Finalizar</button>
                </div>
            </div>
        </div>

        <!-- Tela de Resultados (agora rolável) -->
        <div id="results-screen" class="hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Seu Ranking Final!</h2>
            <ol id="results-list" class="space-y-2 text-left max-w-lg mx-auto mb-8">
                <!-- Resultados serão inseridos aqui -->
            </ol>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 max-w-2xl mx-auto">
                <button id="share-list-btn" class="bg-gray-200 text-gray-800 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition-colors">Enviar esta lista para alguém</button>
                <button id="share-results-btn" class="bg-gray-200 text-gray-800 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition-colors">Enviar o seu ranking para alguém</button>
                <button id="rerank-btn" class="bg-indigo-100 text-indigo-800 font-bold py-3 px-4 rounded-lg hover:bg-indigo-200 transition-colors">Rankear esta lista de novo</button>
                <button id="restart-btn" class="bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors">Começar novo ranking</button>
            </div>
        </div>

    </div>

    <script>
        // --- Elementos da UI ---
        const setupScreen = document.getElementById('setup-screen');
        const battleScreen = document.getElementById('battle-screen');
        const resultsScreen = document.getElementById('results-screen');
        const itemListInput = document.getElementById('item-list');
        const startBtn = document.getElementById('start-btn');
        const itemABtn = document.getElementById('item-a');
        const itemBBtn = document.getElementById('item-b');
        const resultsList = document.getElementById('results-list');
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const listStats = document.getElementById('list-stats');
        const itemCountEl = document.getElementById('item-count');
        const choicesCountEl = document.getElementById('choices-count');
        const restartBattleBtn = document.getElementById('restart-battle-btn');
        const finishEarlyBtn = document.getElementById('finish-early-btn');
        
        const shareListBtn = document.getElementById('share-list-btn');
        const shareResultsBtn = document.getElementById('share-results-btn');
        const rerankBtn = document.getElementById('rerank-btn');
        const restartBtn = document.getElementById('restart-btn');

        // --- Estado do Aplicativo ---
        let originalItems = [];
        let finalRanking = [];
        let comparisonCount = 0;
        let totalComparisons = 0;
        let resolveComparison;
        let isRankingCancelled = false;

        let adj = new Map();
        let inDegree = new Map();

        // --- Lógica Principal ---
        function presentComparison(itemA, itemB) {
            // Correção: Garante que os botões estão perfeitamente resetados
            [itemABtn, itemBBtn].forEach(btn => {
                btn.style.opacity = '1';
                btn.style.transform = 'scale(1)'; // Reseta o scale explicitamente
                btn.classList.remove('winner-animation', 'loser-animation', 'no-hover');
            });
            itemABtn.textContent = itemA;
            itemBBtn.textContent = itemB;
            return new Promise(resolve => {
                resolveComparison = resolve;
                itemABtn.addEventListener('click', choiceHandler);
                itemBBtn.addEventListener('click', choiceHandler);
                document.addEventListener('keydown', keyHandler);
            });
        }

        async function choiceHandler(event) {
            const isClick = event.type === 'click';
            const choice = isClick ? event.currentTarget.id : (event.key === 'ArrowLeft' ? 'item-a' : 'item-b');
            const winnerBtn = (choice === 'item-a') ? itemABtn : itemBBtn;
            const loserBtn = (choice === 'item-a') ? itemBBtn : itemABtn;
            const winner = winnerBtn.textContent;
            const loser = loserBtn.textContent;

            itemABtn.removeEventListener('click', choiceHandler);
            itemBBtn.removeEventListener('click', choiceHandler);
            document.removeEventListener('keydown', keyHandler);
            
            [itemABtn, itemBBtn].forEach(btn => btn.classList.add('no-hover'));
            winnerBtn.classList.add('winner-animation');
            loserBtn.classList.add('loser-animation');
            
            recordChoice(winner, loser);
            
            await new Promise(resolve => setTimeout(resolve, 400));
            
            if (resolveComparison) {
                resolveComparison(winner);
                resolveComparison = null;
            }
        }

        function keyHandler(event) {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                choiceHandler(event);
            }
        }
        
        // --- Algoritmo de Ordenação e Lógica de Ranking ---
        function recordChoice(winner, loser) {
            if (adj.has(winner) && !adj.get(winner).includes(loser)) {
                adj.get(winner).push(loser);
                inDegree.set(loser, inDegree.get(loser) + 1);
            }
        }

        async function merge(left, right) {
            if (isRankingCancelled) return [];
            const result = [];
            let leftIndex = 0, rightIndex = 0;
            while (leftIndex < left.length && rightIndex < right.length) {
                if (isRankingCancelled) return [];
                comparisonCount++;
                updateProgress();
                const itemA = left[leftIndex];
                const itemB = right[rightIndex];
                const winner = await presentComparison(itemA, itemB);
                if (isRankingCancelled) return []; // Checa de novo após a escolha
                if (winner === itemA) {
                    result.push(itemA);
                    leftIndex++;
                } else {
                    result.push(itemB);
                    rightIndex++;
                }
            }
            return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
        }

        async function mergeSort(array) {
            if (array.length <= 1 || isRankingCancelled) return array;
            const middle = Math.floor(array.length / 2);
            const left = array.slice(0, middle);
            const right = array.slice(middle);
            const sortedLeft = await mergeSort(left);
            const sortedRight = await mergeSort(right);
            return await merge(sortedLeft, sortedRight);
        }

        function generatePartialRanking() {
            const ranking = [];
            const localInDegree = new Map(JSON.parse(JSON.stringify(Array.from(inDegree))));
            let queue = originalItems.filter(item => localInDegree.get(item) === 0);
            const rankedItems = new Set();

            while(queue.length > 0) {
                ranking.push(queue.sort()); // Ordena alfabeticamente os empatados
                queue.forEach(item => rankedItems.add(item));
                const nextQueue = [];
                for (const node of queue) {
                    for (const neighbor of adj.get(node) || []) {
                        localInDegree.set(neighbor, localInDegree.get(neighbor) - 1);
                        if (localInDegree.get(neighbor) === 0) {
                            nextQueue.push(neighbor);
                        }
                    }
                }
                queue = nextQueue;
            }
            
            const unranked = originalItems.filter(item => !rankedItems.has(item));
            if(unranked.length > 0) {
                ranking.push(unranked.sort()); // Ordena alfabeticamente os empatados
            }

            return ranking;
        }

        // --- Funções Auxiliares ---
        async function startRanking(itemsToRank) {
            isRankingCancelled = false;
            comparisonCount = 0;
            totalComparisons = calculateMaxComparisons(itemsToRank.length);
            
            adj.clear();
            inDegree.clear();
            itemsToRank.forEach(item => {
                adj.set(item, []);
                inDegree.set(item, 0);
            });

            updateProgress();
            setupScreen.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            battleScreen.classList.remove('hidden');

            await mergeSort([...itemsToRank]);
            
            if (!isRankingCancelled) {
                finalRanking = generatePartialRanking();
                displayResults(finalRanking);
            }
        }
        
        function calculateMaxComparisons(n) {
            if (n <= 1) return 0;
            const T = (n) => {
                if (n <= 1) return 0;
                const m1 = Math.floor(n / 2);
                const m2 = Math.ceil(n / 2);
                return T(m1) + T(m2) + n - 1;
            };
            return T(n);
        }

        function updateItemCounts() {
            const currentItems = itemListInput.value.trim() === '' ? [] : itemListInput.value.trim().split('\n').filter(item => item.trim() !== '');
            const count = currentItems.length;
            itemCountEl.textContent = count;
            choicesCountEl.textContent = calculateMaxComparisons(count);
        }

        function updateProgress() {
            const percentage = totalComparisons > 0 ? Math.round((comparisonCount / totalComparisons) * 100) : 0;
            progressText.textContent = `Escolha ${comparisonCount} de ${totalComparisons} (${percentage}%)`;
            progressBar.style.width = `${percentage}%`;
        }

        function displayResults(ranking) {
            finalRanking = ranking;
            resultsList.innerHTML = '';
            let rankNumber = 1;
            ranking.forEach(tiedGroup => {
                tiedGroup.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'p-3 rounded-lg flex items-center space-x-4';
                    const rankEl = document.createElement('span');
                    rankEl.className = 'text-lg font-bold text-indigo-600 w-8 text-center';
                    rankEl.textContent = `${rankNumber}.`;
                    const textEl = document.createElement('span');
                    textEl.className = 'text-lg';
                    textEl.textContent = item;
                    li.appendChild(rankEl);
                    li.appendChild(textEl);
                    resultsList.appendChild(li);
                });
                rankNumber += tiedGroup.length;
            });
            battleScreen.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
        }
        
        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copiado!';
                setTimeout(() => { button.textContent = originalText; }, 2000);
            }).catch(err => {
                console.error('Falha ao copiar: ', err);
                alert('Não foi possível copiar o texto.');
            });
        }

        // --- Event Listeners ---
        window.addEventListener('load', () => {
            const params = new URLSearchParams(window.location.search);
            const listParam = params.get('list');
            if (listParam) {
                itemListInput.value = listParam.split(',').map(item => decodeURIComponent(item)).join('\n');
            }
            updateItemCounts();
        });

        itemListInput.addEventListener('input', updateItemCounts);

        startBtn.addEventListener('click', () => {
            originalItems = itemListInput.value.trim().split('\n').filter(item => item.trim() !== '');
            if (originalItems.length < 2) {
                alert('Por favor, insira pelo menos dois itens para ranquear.');
                return;
            }
            startRanking(originalItems);
        });
        
        restartBtn.addEventListener('click', () => {
            resultsScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            itemListInput.value = '';
            updateItemCounts();
            window.history.pushState({}, document.title, window.location.pathname);
        });

        rerankBtn.addEventListener('click', () => {
            startRanking(originalItems);
        });

        restartBattleBtn.addEventListener('click', () => {
            isRankingCancelled = true;
            if (resolveComparison) resolveComparison(null);
            battleScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            itemListInput.value = originalItems.join('\n');
            updateItemCounts();
        });

        finishEarlyBtn.addEventListener('click', () => {
            isRankingCancelled = true;
            if (resolveComparison) resolveComparison(null);
            const partialRanking = generatePartialRanking();
            displayResults(partialRanking);
        });

        shareListBtn.addEventListener('click', (e) => {
            const encodedItems = originalItems.map(item => encodeURIComponent(item)).join(',');
            const url = `${window.location.origin}${window.location.pathname}?list=${encodedItems}`;
            if (navigator.share) {
                navigator.share({ title: 'Rankeie esta lista!', url: url });
            } else {
                copyToClipboard(url, e.currentTarget);
            }
        });

        shareResultsBtn.addEventListener('click', (e) => {
            let resultsText = "Meu ranking final:\n";
            let rankNumber = 1;
            finalRanking.forEach(tiedGroup => {
                resultsText += tiedGroup.map(item => `${rankNumber}. ${item}`).join('\n') + '\n';
                rankNumber += tiedGroup.length;
            });

            if (navigator.share) {
                navigator.share({ title: 'Meu Ranking', text: resultsText.trim() });
            } else {
                copyToClipboard(resultsText.trim(), e.currentTarget);
            }
        });
    </script>
</body>
</html>
